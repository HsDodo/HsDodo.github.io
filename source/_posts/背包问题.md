---
title: 背包问题
date: 2021-05-07 20:31:41
tags:
	- 动态规划
	- 背包问题
categories: 算法
cover: https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/20210508171613.jpg
---



<div style='text-align: center;'><h1> <font size=5em color='#ff7f50'>背包问题🎒</font> </h1></div>

---



{% note blue modern%}
背包问题是指在一个有容积或重量限制的背包中放入物品，物品有体积 , 重量 , 价值等属性。要求在满足背包限制的情况下，如何放置物品使背包的价值之和最大。根据物品限制条件的不同，可分为:

​														__01 背包__ ,__完全背包__,__多重背包__,__分组背包__

{% endnote %}



## <font size=4em color='#afdd22'>01背包</font>

>问题描述:
>
>​	给定n个物品，每个物品有重量wi和价值vi,__每种物品有且只有一个__ , 背包容量为W,要求在不超过背包容量的情况下,如何放置物品,使背包中物品价值之和最大,可以对每个物品依次检查是否放入或者不放入。看图理解: dp[ i ] [ j ]表示限制容量为 j 时，前 i 个物品可以取得的最大价值
>
>



![](https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/study/dp01.png)



  

🐳核心代码

```c
int knapsack01(){
	//01背包
	for(int i=0;i<n;i++){
		for(int j=W;j>=weight[i];j--){ //注意这里要逆向推
			dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
		}
	} 
	return dp[W];
}
```

## <font size=4em color='#afdd22'>完全背包</font>

> 问题描述:
>
> ​	给定n个物品，每个物品有重量wi和价值vi,__每种物品的数量没有限制__ , 背包容量为W,要求在不超过背包容量的情况下,如何放置物品,使背包中物品价值之和最大,可以对每个物品依次检查是否放入或者不放入。看图理解: dp[ i ] [ j ]表示限制容量为 j 时，前 i 个物品可以取得的最大价值



![](https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/study/dp02.png)

🦞核心代码

```c#

int knapsack2(){
	//完全背包
	 for(int i=0;i<n;i++){
		for(int j=weight[i];j<W;j++){ //注意这里要正向推，正向推可以放多次
			dp[j]=max(dp[j],dp[j-weight[i]]+value[i]);
		}

	 }
	 return dp[W];
}

```



## <font size=4em color='#afdd22'>多重背包</font>

> 问题描述:
>
> ​	给定n个物品，每个物品有重量wi和价值vi,__每种物品的数量可以大于1但是有限制__ , 背包容量为W,要求在不超过背包容量的情况下,如何放置物品,使背包中物品价值之和最大,可以对每个物品依次检查是否放入或者不放入。看图理解: dp[ i ] [ j ]表示限制容量为 j 时，前 i 个物品可以取得的最大价值

 🐙核心代码

- 方法一 ( 使用数组优化，用数组记录物品使用个数 )

```javascript
int knapsack3(){
	//多重背包 
	for(int i=0;i<n;i++){
		memset(x,0,sizeof(x));
		for(int j=weight[i];j<=W;j++){
			if(dp[j]<(dp[j-weight[i]]+value[i])&&x[j-weight[i]]<num[i]){ //用数组优化，数组记录物品使用个数
				//更新
				dp[j]=dp[j-weight[i]]+value[i];				
				x[j]=x[j-weight[i]]+1;
			}
		}
	}
	
	return dp[W];
}
```

- 方法二 ( 二进制分组,有些题会超时 )

```c++
void multi_knapsack2(int n,int W)//二进制拆分 
{
    for(int i=1;i<=n;i++)
    {
		if(c[i]*w[i]>=W)//转化完全背包 
        {
            for(int j=w[i];j<=W;j++)
                dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
        else
        {
            for(int k=1;c[i]>0;k<<=1)//二进制拆分
        	{
	            int x=min(k,c[i]);
	            for(int j=W;j>=w[i]*x;j--)//转化01背包 
	                dp[j]=max(dp[j],dp[j-w[i]*x]+x*v[i]);
	            c[i]-=x;
        	} 
    	}
	}
}
```



## <font size=4em color='#afdd22'>分组背包</font>

> 问题描述:
>
> ​	给定n组物品,第 i 组第 j 个物品有重量  wij 和 vij ,背包容量为W, 要求在不超过背包容量的情况下,每组至多选择一个物品,如何放置物品,使背包中物品的价值之和最大。 __因为每组至多选择一个物品,可以将每组看作一个整体,这样就类似于 01 背包__

🐡核心代码

```c++
void group_knapsack(int n,int W)//分组背包
{
    for(int i=1;i<=n;i++)
		for(int j=W;j>=0;j--) 
			for(int k=1;k<=c[i];k++){
				if(j>=w[i][k]){//枚举组内各个物品
					dp[j]=max(dp[j],dp[j-w[i][k]]+v[i][k]);                                    
                }
            }
}
```

