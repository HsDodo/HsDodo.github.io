---
title: å¹¶æŸ¥é›†
date: 2021-04-17 23:03:19
author: èŠ±æ£®Â°
cover: https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/5.jpg
tags: 
     - ç®—æ³•
     - å¹¶æŸ¥é›†
     - Union-Find
categories: ç®—æ³•
---

# Union-Find å¹¶æŸ¥é›†

> Union-Find ç®—æ³• ä¹Ÿå°±æ˜¯å¹¶æŸ¥é›†ï¼Œä¸»è¦è§£å†³å›¾è®ºä¸­çš„ ã€åŠ¨æ€è¿é€šæ€§ã€‘ é—®é¢˜ã€‚

## ğŸ–__å…³é”®ä»£ç __

------

ğŸˆ_æ¨¡æ¿â‘ _

```javascript
class UnionFind {
    int[] parents;
    public UnionFind(int totalNodes) {
        parents = new int[totalNodes];
        for (int i = 0; i < totalNodes; i++) {
            parents[i] = i;
        }
    }
		// åˆå¹¶è¿é€šåŒºåŸŸæ˜¯é€šè¿‡findæ¥æ“ä½œçš„, å³çœ‹è¿™ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯ä¸æ˜¯åœ¨ä¸€ä¸ªè¿é€šåŒºåŸŸå†….
    boolean union(int node1, int node2) {
        int root1 = find(node1);
        int root2 = find(node2);
        if (root1 != root2) {
            parents[root2] = root1;
	    	return true;  //è¿æ¥æˆåŠŸ è¿”å›true,è¯´æ˜è¿™ä¸¤ä¸ªèŠ‚ç‚¹å½“å‰å¹¶æ²¡æœ‰ç›¸è¿
        }else{
	    	return false; //å·²ç»ç›¸è¿ ï¼Œè¿”å› false
		}
    }

    int find(int node) {
        while (parents[node] != node) {
            // å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ æŒ‡å‘çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹.
            // ä¿è¯ä¸€ä¸ªè¿é€šåŒºåŸŸæœ€ç»ˆçš„parentsåªæœ‰ä¸€ä¸ª.
            parents[node] = parents[parents[node]];
            node = parents[node];
        }
        return node;
    }
}

```

ğŸˆ_æ¨¡æ¿â‘¡_

```javascript
private class UnionFind {
	//ç”¨äºä¸ç¡®å®šèŠ‚ç‚¹æ•°çš„å¹¶æŸ¥é›†
        private Map<Integer, Integer> parent;
        private int count;
        public UnionFind() {
            this.parent = new HashMap<>();
            this.count = 0;
        }
    
        public int getCount() {
            return count;
        }

        public int find(int x) {
            if (!parent.containsKey(x)) {
                parent.put(x, x);
                // å¹¶æŸ¥é›†é›†ä¸­æ–°åŠ å…¥ä¸€ä¸ªç»“ç‚¹ï¼Œç»“ç‚¹çš„çˆ¶äº²ç»“ç‚¹æ˜¯å®ƒè‡ªå·±ï¼Œæ‰€ä»¥è¿é€šåˆ†é‡çš„æ€»æ•° +1
                count++;
            }
            if (x != parent.get(x)) {
                parent.put(x, find(parent.get(x)));
            }
            return parent.get(x);
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return;
            }
            parent.put(rootX, rootY);
            // ä¸¤ä¸ªè¿é€šåˆ†é‡åˆå¹¶æˆä¸ºä¸€ä¸ªï¼Œè¿é€šåˆ†é‡çš„æ€»æ•° -1
            count--;
        }
    }
}


```



## ğŸ”é£Ÿç”¨æ–¹æ³•

-----

- è¢«å›´ç»•çš„åŒºåŸŸ

![](https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/20210417233759.png)

```javascript
class Solution {
    public void solve(char[][] board) {
        int n=board.length;
        if(n==0) return;
        int m=board[0].length;
        UnionFind uf=new UnionFind(m*n+1);
        int dummy=m*n;
        int[][] dir={{-1,0},{0,-1},{0,1},{1,0}};
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(board[i][j]=='O'){
                    if(i==0||j==0||i==n-1||j==m-1){
                        uf.union(i*m+j,dummy);
                    }
                    for(int k=0;k<4;k++){
                        int x=i+dir[k][0];
                        int y=j+dir[k][1];
                        if(isArea(x,y,n,m)&&board[x][y]=='O'){
                            uf.union(i*m+j,x*m+y);
                        }
                    }
                }
            }
        }

        for(int i=1;i<n-1;i++){
            for(int j=1;j<m-1;j++){
                if(board[i][j]=='O'){
                    if(!uf.isConnected(i*m+j,dummy)){
                        board[i][j]='X';
                    }
                }
            }
        }
    }
    boolean isArea(int x,int y,int row,int colum){
        return x>=0&&x<row&&y>=0&&y<colum;
    }
}
```



