---
title: 并查集
date: 2021-04-17 23:03:19
author: 花森°
cover: https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/5.jpg
tags: 
     - 算法
     - 并查集
     - Union-Find
categories: 算法
---

# Union-Find 并查集

> Union-Find 算法 也就是并查集，主要解决图论中的 【动态连通性】 问题。

## 🍖__关键代码__

------

🎈_模板①_

```javascript
class UnionFind {
    int[] parents;
    public UnionFind(int totalNodes) {
        parents = new int[totalNodes];
        for (int i = 0; i < totalNodes; i++) {
            parents[i] = i;
        }
    }
		// 合并连通区域是通过find来操作的, 即看这两个节点是不是在一个连通区域内.
    boolean union(int node1, int node2) {
        int root1 = find(node1);
        int root2 = find(node2);
        if (root1 != root2) {
            parents[root2] = root1;
	    	return true;  //连接成功 返回true,说明这两个节点当前并没有相连
        }else{
	    	return false; //已经相连 ，返回 false
		}
    }

    int find(int node) {
        while (parents[node] != node) {
            // 当前节点的父节点 指向父节点的父节点.
            // 保证一个连通区域最终的parents只有一个.
            parents[node] = parents[parents[node]];
            node = parents[node];
        }
        return node;
    }
}

```

🎈_模板②_

```javascript
private class UnionFind {
	//用于不确定节点数的并查集
        private Map<Integer, Integer> parent;
        private int count;
        public UnionFind() {
            this.parent = new HashMap<>();
            this.count = 0;
        }
    
        public int getCount() {
            return count;
        }

        public int find(int x) {
            if (!parent.containsKey(x)) {
                parent.put(x, x);
                // 并查集集中新加入一个结点，结点的父亲结点是它自己，所以连通分量的总数 +1
                count++;
            }
            if (x != parent.get(x)) {
                parent.put(x, find(parent.get(x)));
            }
            return parent.get(x);
        }

        public void union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return;
            }
            parent.put(rootX, rootY);
            // 两个连通分量合并成为一个，连通分量的总数 -1
            count--;
        }
    }
}


```



## 🍔食用方法

-----

- 被围绕的区域

![](https://cdn.jsdelivr.net/gh/HsDodo/blogImage/images/20210417233759.png)

```javascript
class Solution {
    public void solve(char[][] board) {
        int n=board.length;
        if(n==0) return;
        int m=board[0].length;
        UnionFind uf=new UnionFind(m*n+1);
        int dummy=m*n;
        int[][] dir={{-1,0},{0,-1},{0,1},{1,0}};
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(board[i][j]=='O'){
                    if(i==0||j==0||i==n-1||j==m-1){
                        uf.union(i*m+j,dummy);
                    }
                    for(int k=0;k<4;k++){
                        int x=i+dir[k][0];
                        int y=j+dir[k][1];
                        if(isArea(x,y,n,m)&&board[x][y]=='O'){
                            uf.union(i*m+j,x*m+y);
                        }
                    }
                }
            }
        }

        for(int i=1;i<n-1;i++){
            for(int j=1;j<m-1;j++){
                if(board[i][j]=='O'){
                    if(!uf.isConnected(i*m+j,dummy)){
                        board[i][j]='X';
                    }
                }
            }
        }
    }
    boolean isArea(int x,int y,int row,int colum){
        return x>=0&&x<row&&y>=0&&y<colum;
    }
}
```



